<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>How to Use ‚Äî MapMyPlot</title>
  <style>
    :root{--accent:#ff5100;--muted:#666}
    body{font-family:Inter, Poppins, system-ui, Arial;line-height:1.5;color:#222;margin:0;background:#fbfbfc}
    header{display:flex;align-items:center;justify-content:space-between;padding:18px 28px;background:#fff;border-bottom:1px solid #eee}
    .logo{display:flex;align-items:center;gap:12px}
    .logo img{height:38px}
    h1{font-size:22px;margin:0}
    main{max-width:1200px;margin:28px auto;padding:20px}
    .layout{display:grid;grid-template-columns:360px 1fr;gap:20px}
    .panel{background:#fff;border-radius:10px;padding:18px;border:1px solid #eee}
    .toc h3{margin-top:0}
    .toc a{display:block;padding:8px 10px;border-radius:6px;color:#333;text-decoration:none;margin-bottom:6px}
    .toc a:hover{background:#fbf0ea}
    .content h2{margin-top:0}
    .step{margin-bottom:18px}
    .kbd{background:#f4f4f6;padding:6px 8px;border-radius:6px;font-family:monospace;font-size:13px}
    /* Demo canvas area */
    .demo-wrap{display:flex;gap:16px}
    #uploader{display:flex;gap:10px;align-items:center}
    #fileInput{display:none}
    .btn{background:var(--accent);color:#fff;padding:10px 12px;border-radius:8px;border:none;cursor:pointer}
    .secondary{background:#fff;color:var(--accent);border:1px solid #ffd0b8}
    .canvas-card{flex:1;display:flex;flex-direction:column;gap:10px}
    #canvas{background:#ddd;width:100%;height:560px;border-radius:8px;border:1px solid #ccc;cursor:crosshair}
    .controls{display:flex;gap:10px;align-items:center}
    label{font-weight:600}
    input[type=number]{width:80px;padding:8px;border-radius:6px;border:1px solid #ccc}
    .areas{max-height:220px;overflow:auto}
    .area-row{display:flex;justify-content:space-between;padding:6px 8px;border-radius:6px;background:#fafafa;margin-bottom:6px}
    .legend{display:flex;gap:8px;flex-wrap:wrap}
    .legend .chip{padding:6px 8px;border-radius:6px;background:#fff;border:1px solid #eee;font-size:13px}
    .note{font-size:13px;color:var(--muted)}
    /* small responsive */
    @media(max-width:920px){.layout{grid-template-columns:1fr;}.canvas-card{order:2}}
  </style>
</head>
<body>
  <header>
    <div class="logo"><img src="./assets/logo.png" alt="logo"><div><h1>MapMyPlot ‚Äî How to use</h1><div style="font-size:12px;color:#666">Quick guide & interactive demo</div></div></div>
    <nav style="display:flex;gap:12px;align-items:center">
      <a href="index.html">Home</a>
      <a href="plot.html" class="btn">Open Tool</a>
    </nav>
  </header>

  <main>
    <div class="layout">
      <aside class="panel toc">
        <h3>Quick Contents</h3>
        <a href="#upload">1. Upload & Trace</a>
        <a href="#partition">2. Partition Modes</a>
        <a href="#adjust">3. Move & Adjust</a>
        <a href="#export">4. Export & Save</a>
        <a href="#demo">Interactive demo</a>
        <hr style="margin:12px 0;border:none;border-top:1px solid #eee">
        <div class="note">Tip: try the interactive demo ‚Äî for a quick real-feel of drawing, generating equal-area partitions, and dragging lines to see areas update in real-time.</div>
      </aside>

      <section class="panel content">
        <h2 id="upload">1. Upload an image or draw your plot</h2>
        <div class="step">
          <p><strong>Upload Image</strong>: Click <span class="kbd">Upload Image</span> and choose a file (jpg, png). The image will be placed in the canvas. If the image comes from Google Maps / Map screenshot, choose a clear top-down view.</p>
          <p class="note">When using map screenshots, georeferencing is required to get real-world areas. This demo uses pixel-space area (Shoelace). For production, use map coordinates (GeoJSON + Turf.js) or project to UTM.</p>
        </div>

        <div class="step">
          <p><strong>Trace / Draw boundary</strong>: Switch to <span class="kbd">Draw</span> mode and click on the canvas to add vertices. Close the polygon by clicking the first point again or by clicking <span class="kbd">Finish Polygon</span>.</p>
        </div>

        <h2 id="partition">2. Partition strategies</h2>
        <div class="step">
          <p><strong>Equal Stripes (MVP)</strong>: Divides the polygon into N vertical (or horizontal) slices with equal area. This is fast and deterministic ‚Äî good for initial splits.</p>
          <p><strong>Bisector Split</strong>: Iteratively splits polygons by area using bisectors ‚Äî better for odd shapes.</p>
          <p><strong>Custom Ratios</strong>: Assign custom area ratios (e.g., 40% / 30% / 30%) ‚Äî useful for inheritance shares.</p>
        </div>

        <h2 id="adjust">3. Move and customize</h2>
        <div class="step">
          <p>After generating partitions, enable <span class="kbd">Drag Mode</span>. Drag handles or partition boundaries. The area values next to each partition update live so you always know exact areas.</p>
          <ul>
            <li>Snap-to-grid / snap-to-vertex (optional)</li>
            <li>Lock a partition area to a target and move others to match</li>
            <li>Color and label each partition</li>
          </ul>
        </div>

        <h2 id="export">4. Export & Save</h2>
        <div class="step">
          <p>Once satisfied, you can export:</p>
          <ul>
            <li><strong>GeoJSON</strong> ‚Äî for map-aware formats (requires georeferenced input)</li>
            <li><strong>PNG / SVG</strong> ‚Äî image of the parcel with partitions</li>
            <li><strong>PDF report</strong> ‚Äî summary of areas and map snapshot</li>
          </ul>
        </div>

        <h2 id="demo">Interactive demo (pixel-space)</h2>
        <div class="step demo-wrap">
          <div class="canvas-card panel" style="padding:12px">
            <div id="uploader">
              <label class="btn" for="fileInput">üì§ Upload Image</label>
              <input id="fileInput" type="file" accept="image/*">
              <button id="drawBtn" class="secondary">‚úèÔ∏è Draw</button>
              <button id="finishBtn" class="secondary">‚úÖ Finish Polygon</button>
              <button id="clearBtn" class="secondary">Clear</button>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px" class="controls">
              <div><label>Partitions</label> <input id="parts" type="number" min="1" value="2"></div>
              <div><button id="genBtn" class="btn">Generate Partitions</button></div>
            </div>
            <canvas id="canvas"></canvas>
            <div style="font-size:13px;color:#666;margin-top:4px">Click to place polygon points. Use <strong>Generate</strong> to create equal vertical partitions. Drag any vertical line to see areas update.</div>
          </div>

          <aside class="panel" style="width:320px">
            <h3>Partitions</h3>
            <div class="areas" id="areas"></div>
            <div style="margin-top:10px"><strong>Total area (pixels¬≤):</strong> <span id="totalArea">‚Äî</span></div>
            <hr style="margin:12px 0">
            <div class="legend"><div class="chip">Try: upload map screenshot</div><div class="chip">Draw irregular shapes</div><div class="chip">Drag to fine-tune</div></div>
          </aside>
        </div>

        <hr style="margin:18px 0">
        <h3>More tips</h3>
        <p class="note">For real-world measurements use the map mode with GeoJSON and compute geodesic areas using Turf.js or project to UTM for high latitude accuracy. For legal use, always cross-check measurements with cadastral documents.</p>
      </section>
    </div>
  </main>

  <script>
    /* Minimal interactive demo: draw polygon on canvas, generate equal vertical partitions, allow dragging vertical cuts and compute area (shoelace) for each clipped polygon. This is pixel-space demo ‚Äî not georeferenced. */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');
    const drawBtn = document.getElementById('drawBtn');
    const finishBtn = document.getElementById('finishBtn');
    const clearBtn = document.getElementById('clearBtn');
    const genBtn = document.getElementById('genBtn');
    const partsInput = document.getElementById('parts');
    const areasEl = document.getElementById('areas');
    const totalAreaEl = document.getElementById('totalArea');

    let W = 900, H = 560; // default canvas size
    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width || W;
      canvas.height = rect.height || H;
    }
    // set initial size
    canvas.style.width = '100%';
    canvas.style.height = H + 'px';
    resizeCanvas();
    window.addEventListener('resize', ()=>{resizeCanvas(); drawAll();});

    // state
    let image = null;
    let drawing = false;
    let polygon = [];
    let partitions = []; // array of x positions for vertical cuts (n-1 cuts for n parts)
    let dragging = {index:-1, offsetX:0};

    // helpers
    function clearState(){ polygon=[]; partitions=[]; dragging={index:-1,offsetX:0}; updateAreas(); drawAll(); }

    // shoelace area
    function polygonArea(pts){
      if(!pts || pts.length<3) return 0;
      let a=0; for(let i=0;i<pts.length;i++){let j=(i+1)%pts.length; a+= pts[i].x*pts[j].y - pts[j].x*pts[i].y; } return Math.abs(a)/2;
    }

    // Sutherland‚ÄìHodgman polygon clipping against rectangle [xmin, ymin, xmax, ymax]
    function clipPolygon(subject, rect){
      if(!subject || subject.length===0) return [];
      let [xmin,ymin,xmax,ymax] = rect;
      let output = subject;
      // helper for each edge
      function clipEdge(input, edge){
        if(input.length===0) return [];
        const out = [];
        for(let i=0;i<input.length;i++){
          const curr = input[i];
          const prev = input[(i-1+input.length)%input.length];
          const insideCurr = edge.inside(curr);
          const insidePrev = edge.inside(prev);
          if(insideCurr){
            if(!insidePrev){ // entering: add intersection
              const ip = edge.intersect(prev,curr);
              if(ip) out.push(ip);
            }
            out.push(curr);
          } else if(insidePrev){ // exiting: add intersection
            const ip = edge.intersect(prev,curr);
            if(ip) out.push(ip);
          }
        }
        return out;
      }
      // define edges: left, right, top, bottom
      const edges = [
        {inside: p=> p.x>=xmin, intersect: (a,b)=> intersectSegWithX(a,b,xmin)},
        {inside: p=> p.x<=xmax, intersect: (a,b)=> intersectSegWithX(a,b,xmax)},
        {inside: p=> p.y>=ymin, intersect: (a,b)=> intersectSegWithY(a,b,ymin)},
        {inside: p=> p.y<=ymax, intersect: (a,b)=> intersectSegWithY(a,b,ymax)},
      ];
      for(const e of edges) output = clipEdge(output,e);
      return output;
    }
    function intersectSegWithX(a,b,x){
      const dx = b.x-a.x; if(Math.abs(dx)<1e-9) return null; const t = (x - a.x)/dx; if(t< -1e-9 || t>1+1e-9) return null; return {x:x, y: a.y + t*(b.y-a.y)};
    }
    function intersectSegWithY(a,b,y){
      const dy = b.y-a.y; if(Math.abs(dy)<1e-9) return null; const t = (y - a.y)/dy; if(t< -1e-9 || t>1+1e-9) return null; return {x: a.x + t*(b.x-a.x), y:y};
    }

    // draw
    function drawAll(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(image) ctx.drawImage(image,0,0,canvas.width,canvas.height);
      // polygon
      ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,0.7)'; ctx.fillStyle='rgba(255,255,255,0.0)';
      if(polygon.length){
        ctx.beginPath(); ctx.moveTo(polygon[0].x,polygon[0].y); for(let i=1;i<polygon.length;i++) ctx.lineTo(polygon[i].x,polygon[i].y); ctx.closePath(); ctx.stroke();
        // vertices
        for(const p of polygon){ ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,2*Math.PI); ctx.fill(); ctx.stroke(); }
      }
      // partitions
      if(partitions && partitions.length){
        // draw each partition fill
        const n = partitions.length+1;
        const colors = generateColors(n);
        for(let i=0;i<n;i++){
          const x0 = (i===0?0:partitions[i-1]);
          const x1 = (i===n-1?canvas.width:partitions[i]);
          const clipped = clipPolygon(polygon, [x0,0,x1,canvas.height]);
          if(clipped.length){ ctx.fillStyle = hexToRgba(colors[i],0.22); ctx.beginPath(); ctx.moveTo(clipped[0].x,clipped[0].y); for(let k=1;k<clipped.length;k++) ctx.lineTo(clipped[k].x,clipped[k].y); ctx.closePath(); ctx.fill(); ctx.stroke(); }
        }
        // draw vertical cut lines
        ctx.strokeStyle='rgba(0,0,0,0.8)'; ctx.lineWidth=2;
        partitions.forEach((x,i)=>{ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); // handle
          ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(x,40,10,0,2*Math.PI); ctx.fill(); ctx.stroke(); });
      }
    }

    function generateColors(n){ const palette = ['#FF8A80','#FFD180','#FFFF8D','#CCFF90','#80D8FF','#B388FF','#FF80AB']; const out=[]; for(let i=0;i<n;i++) out.push(palette[i%palette.length]); return out; }
    function hexToRgba(hex,alpha){hex=hex.replace('#','');const r=parseInt(hex.substring(0,2),16),g=parseInt(hex.substring(2,4),16),b=parseInt(hex.substring(4,6),16);return `rgba(${r},${g},${b},${alpha})`;}

    // compute partition areas
    function computeAreas(){
      const n = (partitions.length?partitions.length+1:0);
      const areas = [];
      if(n===0) return {areas:[], total:0};
      for(let i=0;i<n;i++){
        const x0=(i===0?0:partitions[i-1]); const x1=(i===n-1?canvas.width:partitions[i]);
        const clipped = clipPolygon(polygon, [x0,0,x1,canvas.height]);
        areas.push(polygonArea(clipped));
      }
      const total = areas.reduce((a,b)=>a+b,0);
      return {areas,total};
    }

    function updateAreas(){ areasEl.innerHTML=''; const res = computeAreas(); totalAreaEl.textContent = Math.round(res.total);
      res.areas.forEach((a,i)=>{ const div = document.createElement('div'); div.className='area-row'; div.innerHTML=`<div>Partition ${i+1}</div><div>${Math.round(a)} px¬≤</div>`; areasEl.appendChild(div); }); }

    // events: upload
    fileInput.addEventListener('change', (ev)=>{
      const f = ev.target.files[0]; if(!f) return; const img = new Image(); const url = URL.createObjectURL(f);
      img.onload = ()=>{ image = img; drawAll(); URL.revokeObjectURL(url); };
      img.src = url;
    });

    // draw mode
    drawBtn.addEventListener('click', ()=>{ drawing = !drawing; drawBtn.textContent = drawing? 'üî¥ Drawing':'‚úèÔ∏è Draw'; canvas.style.cursor = drawing? 'crosshair':'default'; });
    finishBtn.addEventListener('click', ()=>{ drawing=false; drawBtn.textContent='‚úèÔ∏è Draw'; canvas.style.cursor='default'; drawAll(); });
    clearBtn.addEventListener('click', ()=>{ clearState(); image=null; fileInput.value=''; drawAll(); });

    canvas.addEventListener('click', (ev)=>{
      const rect = canvas.getBoundingClientRect(); const x = (ev.clientX - rect.left)*(canvas.width/rect.width); const y = (ev.clientY - rect.top)*(canvas.height/rect.height);
      if(drawing){ polygon.push({x,y}); drawAll(); }
    });

    // generate equal vertical partitions
    genBtn.addEventListener('click', ()=>{
      const n = Math.max(1, parseInt(partsInput.value)||1);
      if(polygon.length<3){ alert('Draw a polygon first'); return; }
      partitions = [];
      // find polygon bounding box
      let minX=Infinity, maxX=-Infinity; polygon.forEach(p=>{minX=Math.min(minX,p.x);maxX=Math.max(maxX,p.x)});
      const w = maxX-minX; for(let i=1;i<n;i++){ partitions.push(minX + w*(i/n)); }
      drawAll(); updateAreas();
    });

    // dragging logic: detect mousedown near a partition line
    canvas.addEventListener('mousedown', (ev)=>{
      const rect = canvas.getBoundingClientRect(); const mx = (ev.clientX-rect.left)*(canvas.width/rect.width);
      // find nearest partition within 12px
      let idx=-1; let dmin=12; partitions.forEach((x,i)=>{const d=Math.abs(x-mx); if(d<dmin){dmin=d; idx=i;}});
      if(idx!==-1){ dragging.index=idx; dragging.offsetX = partitions[idx]-mx; }
    });
    window.addEventListener('mousemove', (ev)=>{
      if(dragging.index===-1) return;
      const rect = canvas.getBoundingClientRect(); const mx = (ev.clientX-rect.left)*(canvas.width/rect.width);
      let newX = mx + dragging.offsetX;
      // clamp between neighbors
      const left = (dragging.index===0?0:partitions[dragging.index-1]+8);
      const right = (dragging.index===partitions.length-1?canvas.width:partitions[dragging.index+1]-8);
      newX = Math.max(left, Math.min(right, newX)); partitions[dragging.index]=newX; drawAll(); updateAreas();
    });
    window.addEventListener('mouseup', ()=>{ dragging.index=-1; });

    // initialize default polygon example
    (function seedExample(){ const w=canvas.width,h=canvas.height; polygon=[{x:120,y:80},{x:760,y:70},{x:820,y:400},{x:430,y:520},{x:140,y:420}]; drawAll(); })();
  </script>
</body>
</html>
